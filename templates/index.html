<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Live Face Recognition</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background-color: black;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 { color: violet; margin: 20px; }
    .video-box {
      position: relative;
      width: 60%;
      height: 480px;
      background: #222;
      border-radius: 10px;
      overflow: hidden;
    }
    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    #alertMessage {
      position: fixed;
      top: -50px;
      width: 100%;
      text-align: center;
      background-color: #ff3e3e;
      color: white;
      font-weight: bold;
      padding: 12px 0;
      transition: top 0.5s ease;
      z-index: 1000;
    }
    .controls { margin: 15px; }
    button {
      padding: 10px 20px;
      margin: 0 10px;
      font-weight: bold;
      border: none;
      border-radius: 5px;
      background: linear-gradient(90deg,#c850c0,#4158d0);
      color: black;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div id="alertMessage"></div>
  <h1>AI Live Face Recognition</h1>
  <div class="controls">
    <button id="startBtn">Start Webcam</button>
    <button id="stopBtn" disabled>Stop Webcam</button>
  </div>
  <div class="video-box">
    <video id="webcam" autoplay playsinline></video>
    <canvas id="overlayCanvas"></canvas>
  </div>

<script>
const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const webcam = document.getElementById("webcam");
const overlayCanvas = document.getElementById("overlayCanvas");
const ctx = overlayCanvas.getContext("2d");

let stream = null;
let running = false;
let animationFrameId = null;
let trackedFaces = [];
const SMOOTHING = 0.4;

function showAlert(msg) {
  const alertDiv = document.getElementById("alertMessage");
  alertDiv.textContent = msg;
  alertDiv.style.top = "0";
  setTimeout(() => { alertDiv.style.top = "-50px"; }, 3000);
}

function drawBoxes(faces) {
  if (!running) return; // Prevent drawing after stop
  ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  faces.forEach(face => {
    const prev = trackedFaces.find(f => f.name === face.name) || {};
    const x = prev.x !== undefined ? prev.x + SMOOTHING * (face.x - prev.x) : face.x;
    const y = prev.y !== undefined ? prev.y + SMOOTHING * (face.y - prev.y) : face.y;
    const w = prev.w !== undefined ? prev.w + SMOOTHING * (face.w - prev.w) : face.w;
    const h = prev.h !== undefined ? prev.h + SMOOTHING * (face.h - prev.h) : face.h;

    ctx.strokeStyle = face.name === "Unknown" ? "red" : "green";
    ctx.lineWidth = 3;
    ctx.strokeRect(x, y, w, h);
    ctx.fillStyle = ctx.strokeStyle;
    ctx.font = "18px 'Segoe UI'";
    ctx.fillText(face.name, x, y > 20 ? y - 5 : y + 20);

    face.x = x; face.y = y; face.w = w; face.h = h;
  });
  trackedFaces = faces;
}

async function sendFrameToBackend() {
  if (!running) return []; // Prevent sending when stopped
  const canvas = document.createElement("canvas");
  canvas.width = webcam.videoWidth;
  canvas.height = webcam.videoHeight;
  const c = canvas.getContext("2d");
  c.drawImage(webcam, 0, 0);
  return new Promise(resolve => {
    canvas.toBlob(async blob => {
      if (!running) return resolve([]); // Stop instantly
      const formData = new FormData();
      formData.append("image", new File([blob], "frame.jpg", { type: "image/jpeg" }));
      try {
        const res = await fetch("/recognize", { method: "POST", body: formData });
        if (!res.ok) throw new Error("Server returned " + res.status);
        const data = await res.json();
        resolve(data.faces || []);
      } catch (err) {
        if (running) console.error("Backend error:", err);
        resolve([]);
      }
    }, "image/jpeg", 0.5);
  });
}

async function processWebcam() {
  if (!running) return;
  const faces = await sendFrameToBackend();
  if (!running) return; // Prevent drawing after stop
  drawBoxes(faces);
  animationFrameId = requestAnimationFrame(processWebcam);
}

async function startWebcam() {
  try {
    if (running) return;
    running = true;
    trackedFaces = [];
    startBtn.disabled = true;
    stopBtn.disabled = false;

    stream = await navigator.mediaDevices.getUserMedia({
      video: { width: 640, height: 480 },
      audio: false
    });

    webcam.srcObject = stream;
    webcam.onloadedmetadata = () => {
      overlayCanvas.width = webcam.videoWidth;
      overlayCanvas.height = webcam.videoHeight;
      processWebcam();
    };
  } catch (err) {
    showAlert("Cannot access webcam: " + err.message);
    running = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
  }
}

function stopWebcam() {
  if (!running) return;
  running = false;

  // Stop rendering loop first
  cancelAnimationFrame(animationFrameId);
  animationFrameId = null;

  // Immediately clear everything
  ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  trackedFaces = [];

  // Stop webcam stream completely
  if (stream) {
    stream.getTracks().forEach(track => track.stop());
    stream = null;
  }

  webcam.srcObject = null;

  startBtn.disabled = false;
  stopBtn.disabled = true;
}
 
startBtn.addEventListener("click", startWebcam);
stopBtn.addEventListener("click", stopWebcam);
</script>

</body>
</html>